---
id: 79
title: 'Linux 学习 第六章 管理运行中的进程'
date: '2022-12-03T15:07:03+08:00'
author: yexca
layout: post
guid: 'https://yexca.xyz/?p=996'
permalink: /archives/79
argon_hide_readingtime:
    - 'false'
argon_meta_simple:
    - 'false'
argon_first_image_as_thumbnail:
    - default
argon_show_post_outdated_info:
    - default
argon_after_post:
    - ''
argon_custom_css:
    - ''
views:
    - '171'
categories:
    - Linux
tags:
    - 读书笔记
---

## 第六章 管理运行中的进程

Linux 是一种多用户的操作系统，也是一种多任务系统。多任务意味着可以同时运行多个程序，运行程序的实例通常被称为进程

可通过 shell 启动、暂停、停止或杀死进程，还可将进程放到后台以及带到前台

### 6.1 理解进程

进程是命令的运行实例。系统中的进程通过一个进程 ID (PID) 进行识别，PID 相对于当前系统是唯一的。除了 PID 号之外，进程还与一个特定的用户账户和组账号相关联，有助于确定该进程可以访问哪些系统资源

> 用来显示进程相关信息的命令主要从 /proc 文件系统中存储的原始数据获取信息。每个进程都在 /proc 的一个子目录 (以该进程的 PID 命名) 中存储了自己的信息

### 6.2 列出进程

使用 `ps` 命令或者 `top` 命令，其中 top 命令提供了一种 更面向屏幕的方式列出进程

#### 6.2.1 使用 ps 命令列出进程

使用 `ps u` 可显示用户名以及其他信息

VSZ：虚拟内存大小 (Virtual Set Size) 显示了镜像进程的大小 (单位：KB)

RSS：(Resident Set Size) 显示了内存中程序的大小

VSZ 是分配给进程的内存数量，RSS 是进程实际使用的内存数量 (表明了不能被交换的物理内存)

STAT 列：S 表示一个当前运行的进程，R 表示一个睡眠进程，+ 表示进程与前台操作相关联

查看当前用户所有进程：`ps ux | less`

查看所有用户进程：`ps aux | less`

也可以自定义输出列，并且根据某一列排序，例如

```bash
ps -eo pid,user,uid,group,gid,vsz,rss,comm --sort=-vsz | less
```

`-e` 为显示每一个运行中的进程，`-o` 后为显示的列，其中 `comm` 为命令，然后 `--sort=-vsz` 以 vsz 列从大到小排序

#### 6.2.2 使用 top 命令列出和更改进程

使用 `top` 命令，默认按进程当前所使用的 CPU 百分比排序来显示进程

top 命令可以完成的操作：

| 命令 | miaos                                      |
| ---- | ------------------------------------------ |
| h    | 帮助                                       |
| M    | 按内存使用情况排序                         |
| 1    | 切换显示所有 CPU 使用情况 (系统有多个 CPU) |
| R    | 反向排序                                   |
| u    | 然后输入用户名可以显示某用户的进程         |
| r    | 改变进程优先级 (nice 值)                   |
| k    | 杀死进程 (kill 命令)                       |

#### 6.2.3 使用 System Monitor 列出进程

GNOME 桌面的 GUI 工具

### 6.3 管理后台和前台进程

对于没有 GUI 的系统，只能使用 shell 完成所有操作。虽然 Bash shell 没有包含一个 GUI 来管理多个程序，但可以在后台和前台直接移动活动程序，这样就可以运行很多程序并选择目前想要处理的程序

#### 6.3.1 启动后台进程

将命令放入后台：

1. 在命令后添加一个 `&`

2. 使用 `at` 命令运行其他命令

3. 对于运行中的进程使用 *Ctrl+Z* 停止，再输入 `fg` 带回前台或 `bg` 开始在后台运行

> 为避免后台输出干扰前台操作，可将其定向到空设备 `2>/dev/null`

可通过 `jobs` 命令查看后台运行的命令 (使用 `-l` 可查看 PID) 。在命令序号前 `+` 表示最近放到后台的作业，`-` 表示在最近放的后台作业之前放到后台的作业

#### 6.3.2 使用前台和后台命令

如果想引用一个后台作业，通过 `%` 和作业编号 (jobs 命令的输出) ，此外还有如下方式

* `%` --- 引用最近放入后台的 (即编号后带有 + 的)

* `%string` --- 以 string 开头的作业 (必须明确，即匹配结果唯一)

* `%?string` --- 命令行任意位置包含 string (同样必须明确，即匹配结果唯一)

* `%--` --- 引用在最近放的后台作业之前放到后台的作业 (即编号后带有 - 的)

使用 `fg %1` 以将编号为 1 的任务带到前台，使用 `bg %5` 以将停止的编号为 5 的命令在后台继续运行

> 对于 vi 命令放到后台前会自动停止，记得先保存文件再放入后台以防忘记

### 6.4 杀死和改变进程

可以向进程发送不同的信号来更改其行为，也可以更改进程的处理器优先级

#### 6.4.1 使用 kill 和 killall 命令杀死进程

虽然这俩命令常用于终止一个运行中的进程，但实际上是向进程发送一些有效信号。信号通过数字或名称来表示

| 信号    | 数字       | 描述                         |
| ------- | ---------- | ---------------------------- |
| SIGHUP  | 1          | 重新读取配置文件             |
| SIGIN   | 2          | 通过键盘中断                 |
| SIGQUIT | 3          | 通过键盘退出                 |
| SIGABRT | 6          | 调用 abort(3) 生成的中止信号 |
| SIGKILL | 9          | 杀死信号                     |
| SIGTERM | 15         | 终止信号                     |
| SIGCONT | 19，18，25 | 继续被停止的进程             |
| SIGSTOP | 17，19，23 | 停止进程                     |

对于最后两个信号，第一个值适用于 Alpha 和 SPARC，中间的值适用于 x86，最后一个值适用于 MIPS 体系结构

默认为 SIGTERM (15) 信号。虽然不同进程可以对不同信号予以响应，然而任何进程都不能阻止 SIGKILL (9) 和 SIGSTOP 信号

1. 使用 kill 命令并根据 PID 向进程发送信息

```bash
kill [信号] [PID]
```

例如杀死进程 ID 为 2333 的进程：`kill -9 2333` 或者 `kill -SIGKILL 2333`

2. 使用 killall 命令并根据名称向进程发送信号

与 kill 命令类似，当要杀死许多同名命令很有用，但要防止改变有用的同名进程

例如重启 gnome-shell：`killall -1 gnome-shell`

#### 6.4.2 使用 nice 和 renice 命令设置处理器优先级

当 Linux 内核尝试决定哪些运行中的进程可以访问 CPU 时，其中一个需要考虑的因素就是进程上的 nice 值，范围 -20~19，默认为 0

nice 值越低，优先级越高，只有 root 用户可以设置负值并将优先级调高 (值调低)，普通用户只能调低 (值调高)

可以使用 `nice` 命令运行一个带有特定 nice 值的命令，也可以使用 `renice` 命令和 PID 更改已运行进程的 nice 值，例如

`nice -n +5 updatedb &` 在后台以 5 的优先级运行 updatedb 命令

`renice -n 3 2333` 将 PID 为 2333 的进程的 nice 值改为 3

### 6.5 使用 cgroups 限制进程

为一个进程所设置的 nice 值不能应用于子进程，也就是说，nice 无法对特定用户或应用程序可以使用的 Linux 系统资源总量进行限制

可以使用 cgroups 命令将一个进程确定为一个任务 (task)，并从属于一个特定的控制组。可以在一个层次结构中设置任务，其中包含一个被称为守护进程 (daemon) 的任务 (为所有后台服务器进程设置了默认限制) 以及子任务，子任务设置像 httpd 或 vsftpd 上的特定限制

当一个任务启动一个进程时，其子进程将继承父进程限制设置，限制内容包括存储、处理器调度、进程报告、CPU 分配、设备访问、内存使用情况等

设置 cgroups 可能非常棘手，包括编辑配置文件创建 cgroups (/etc/cgconfig.conf) 或限制特定用户或组 (/etc/cgrules.conf) 。可以使用 cgreate 命令创建 cgroups，从而将这些组添加到 /sys/fs/cgroup 层次结构中。如果设置不正确，系统可能无法启动