---
id: 92
title: '数据库学习七 数据库的控制功能'
date: '2023-02-12T08:15:00+08:00'
author: yexca
layout: post
guid: 'https://yexca.xyz/?p=1039'
permalink: /archives/92
argon_hide_readingtime:
    - 'false'
argon_meta_simple:
    - 'false'
argon_first_image_as_thumbnail:
    - default
argon_show_post_outdated_info:
    - default
argon_after_post:
    - ''
argon_custom_css:
    - ''
views:
    - '70'
categories:
    - 编程基础
    - 数据库
---

## 事务管理

事务是一个操作序列，这些操作 "要么都做，要么都不做"

事务和程序是两个不同的概念，一般一个程序可包含多个事务

在 SQL 语言中，事务定义的语句有以下三条

```sql
-- 事务开始
BEGIN TRANSACTION
-- 事务提交
COMMIT
-- 事务回滚
ROLLBACK
```

事务具有 ACID 性质，原子性 (Atomicity) 、一致性 (Consistency) 、隔离性 (Isolation) 和持久性 (Durability)

* 1 原子性

事务是原子的，要么都做，要么都不做

* 2 一致性

事务执行的结果必须保证数据库从一个一致性状态变到另一个一致性状态

因此，当数据库只包含成功事务提交的结果时，称数据库处于一致性状态

* 3 隔离性

事务相互隔离

当多个事务并发执行时，任一事务的更新操作直到其成功提交的整个过程，对其他事务都是不可见的

* 4 持久性

一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效

## 数据库的备份与恢复

在数据库的运行过程中，难免会出现计算机系统的软、硬件故障，这些故障会影响数据库中数据的正确性，甚至破坏数据库，使数据库中的全部或部分数据丢失。因此，数据库的关键技术在于建立冗余数据，即备份数据。如何在系统出现故障后能够及时地使数据库恢复到故障前地正确状态，就是数据库恢复技术

### 故障类型

数据库中的 4 类故障

* 1 事务内部故障

采取REDO重做和UNDO撤销技术

* 2 系统故障 DBMS

系统突然停转，系统要重启

* 3 介质故障

硬件损坏

* 4 计算机病毒

### 备份方法

恢复的基本原理是 "建立数据冗余" (重复存储) 。建立冗余数据的方法是进行数据转储和登记日志文件。数据的转储分为静态转储和动态转储、海量转储和增量转储、日志文件

* 1 静态转储和动态转储

静态转储是指在转储期间不允许对数据库进行任何存取、修改操作

动态转储是在转储期间允许对数据库进行存取、修改操作

因此，转储和用户事务可并发执行

* 2 海量转储和增量转储

海量转储是指每次转储全部数据

增量转储是指每次只转储上次转储后更新过的数据

* 3 日志文件

在事务处理的过程中，DBMS (数据库管理系统) 把事务开始、事务结束以及对数据库的插入、删除和修改的每一次操作写入日志文件。一旦发生故障，DBMS 的恢复子系统利用日志文件撤销事务对数据库的改变，回退到事务的初始状态。因此，DBMS 利用日志文件来进行事务故障恢复和系统故障恢复，并可协助后备副本进行介质故障恢复

### 恢复

* 事务恢复有以下 3 个步骤

1. 反向扫描文件日志 (即从最后向前扫描日志文件) ，查找该事务的更新操作
2. 对事务的更新操作执行逆操作
3. 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样的处理，直到事务的开始标志

即事务异常终止，那么就撤销之前的所有操作

* 系统故障的恢复

还没执行完的事务UNDO，丢失的事务REDO

* 介质故障的恢复

重装数据库，重做已经完成的事务

## 并发控制

### 并发操作带来的问题

* 1 丢失修改

我修改的东西没生效。比如我把网站logo改了，结果还是原来的

* 2 不可重复读

我在一个事务中，连续两次读到的数据不一样
比如我刚开始读到银行余额为10元。此时单位突然发工资100元，那么第二次读就变成110元

* 3 读脏数据

我要读取字段A，B，但读取时其他用户正在更新这两个字段
如果他跟新到一半我就读取（更新了A，正在更新B），此时读取的数据就是脏数据

### 并发控制技术

并发控制的主要技术是封锁。基本封锁的类型有排他锁 (简称 X 锁或写锁) 和共享锁 (简称 S 锁或读锁)

* 1 排他锁

若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其他事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁

* 2 共享锁

若事务 T 对数据对象 A 加上 S 锁，则只允许 T 读取 A，但不能修改 A，其他事务只能再对 A 加 S 锁，直到 T 释放 A 上的 S 锁。这就保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 进行任何修改

### 封锁协议

* 一级封锁协议（解决丢失修改）

修改时，必须加X锁，直到结束

* 二级封锁协议（解决读脏数据）

读的时候，加S锁，用完就放

* 三级封锁协议（解决不可重复读）

读的时候，加S锁，直到结束

### 可串行性

假设多种情况都可以，然后获得结果
如果并发执行的结果跟上面的结果里面任意一个一样就可以

事务T1：读取B，A=B+1，写回A
事务T2：读取A，B=A+1，写回B

那么结果假设先T1，再T2，那么A=4，B=3；
假设先T2，再T1，那么A=3，B=4.
这个并发执行满足可串行性

## 分布式数据库

* 分片透明

用户或应用程序不需要知道逻辑上访问的表具体是怎么分块存储的

* 复制透明

采用复制技术的分布方法，用户不需要知道数据是复制到哪些节点，如何复制的

* 位置透明

用户无需知道数据存放的物理位置

* 逻辑透明

用户或应用程序无需知道局部场地使用的是哪种数据模型

---

* 共享性

数据存储在不同的结点数据共享

* 自治性

每结点对本地数据都能独立管理

* 可用性

当某一场地故障时，系统可以使用其他场地上的副本而不至于使整个系统瘫痪

* 分布性

数据在不同场地上的存储